% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/featureImportance.R
\name{featureImportance}
\alias{featureImportance}
\title{Feature Importance}
\usage{
featureImportance(object, data, features = NULL, target = NULL,
  n.feat.perm = 50, local = FALSE, measures, minimize = NULL,
  predict.fun = NULL, importance.fun = function(permuted, unpermuted,
  minimize) ifelse(minimize, -1, 1) * (unpermuted - permuted), ...)
}
\arguments{
\item{object}{[any] \cr
Either a \code{\link[mlr]{WrappedModel}} or a \code{\link[mlr]{ResampleResult}}.
You can also provide any other trained model (however, this is experimental and you need to provide an appropriate \code{predict.fun}).}

\item{data}{[\code{data.frame}] \cr
The data whose features will be permuted in order to measure their importance.
If \code{object} is of class \code{ResampleResult}, you should use the corresponding data on which the whole resampling was performed. In any other case, you might use some independent test data that was not used to fit the model (although you could also use the train data here).}

\item{features}{[list of \code{character}] \cr
A list where each element contains the names of at least one feature for which the permutation importance is computed.
If a list element contains two or more features, they will be permuted block-wise (without breaking the relationship between those features).}

\item{target}{[\code{character(1)}] \cr
Only needed if \code{object} is not of class \code{WrappedModel} or \code{ResampleResult}.
Name of the target feature to be predicted.}

\item{n.feat.perm}{[\code{numeric(1)}] \cr
The number of permutations of the feature(s) used to compute the feature importance.
The default is 50.}

\item{local}{[\code{logical(1)}] \cr
Should the performance (or the feature importance) be computed observation-wise?
Note that not all measures support this (e.g. one can not compute the AUC for one observation).
The default is FALSE.}

\item{measures}{[\code{\link[mlr]{Measure}} | list of \code{\link[mlr]{Measure}} | \code{function} | list of \code{function}] \cr
Performance measure(s) used to measure the model performance.
Can also be a named list of function with signature \code{function(y, pred)},
where \code{y} and \code{pred} are vectors containing the true and the predicted values of the target.}

\item{minimize}{[named \code{logical}] \cr
Only needed if passed \code{measures} is a named list of functions.
A named logical of the same length and with the same names as \code{measures} answering the question if smaller values of the measure refer to a better model performance.}

\item{predict.fun}{[\code{function}] \cr
Only needed if \code{object} is not of class \code{WrappedModel} or \code{ResampleResult}.
The signature must be \code{function(object, newdata)} and the function should always return a vector of predictions.
The default \code{NULL} internally uses \code{predict(object, newdata = newdata)}.}

\item{importance.fun}{[\code{function}] \cr
Function with signature \code{function(permuted, unpermuted, minimize)} which defines how the permuted and unpermuted predictions are aggregated to a feature importance measure.
The function takes the result of \code{\link{measurePerformance}} as input for \code{permuted} and \code{unpermuted}.
The argument \code{minimize} can be used in \code{importance.fun} to change the aggregation behaivour depending on whether the measure is to be minimized or not, e.g. for the drop in performance: \cr
\code{ifelse(minimize, -1, 1) * (unpermuted - permuted)} \cr
The default \code{NULL} internally uses \code{permuted - unpermuted} (or \code{unpermuted - permuted}, depending on whether the measure is to be minimized or not) which refers to the drop in performance.}

\item{...}{Not used.}
}
\description{
Measures the feature importance by drop in performance.
}
